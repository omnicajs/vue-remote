import type {
  Component,
  Ref,
  ShallowRef,
} from 'vue'

import type {
  Receiver,
  Received,
  ReceivedChild,
} from '@/dom/host'

import type { Unknown } from '~types/scaffolding'

import {
  computed,
  ref,
  shallowRef,
  watch,
} from 'vue'

import {
  retain,
  release,
} from '@remote-ui/rpc'

import { isFunction } from '@/dom/host'

export interface ShallowHosted<T extends Received = Received> {
  node: ShallowRef<T>;
  properties: Ref<Unknown | undefined>;
  /** Is used for linking with tree generated by Vue */
  ref: Ref<Component<NonNullable<unknown>> | Element | null>;
  update (): void;
  release (): void;
}

export interface Hosted<T extends Received = Received> extends ShallowHosted<T> {
  children: ShallowRef<Hosted[]>;
}

export default function useReceived<T extends Received>(
  receiver: ShallowRef<Receiver>,
  node: ShallowRef<T>
): Hosted<T> {
  const parent = useNode(receiver, node)
  const children = useChildren(parent.node, (child: ReceivedChild) => {
    return useReceived(receiver, shallowRef(child))
  })

  return {
    node: parent.node,
    properties: parent.properties,
    children: children.ref,
    ref: parent.ref,
    update: () => {
      parent.update()
      children.update()
    },
    release: () => {
      children.stopWatch()
      children.release()
      parent.release()
    },
  }
}

const isUpdated = <T extends Received>(a: T | null, b: T | null): boolean => {
  return a?.id !== b?.id || a?.version !== b?.version
}

export function useNode<T extends Received>(
  receiver: ShallowRef<Receiver>,
  node: ShallowRef<T>
): ShallowHosted<T> {
  const _node: ShallowRef<T> = shallowRef<T>({ ...node.value })
  const _properties = useProperties(_node)
  const _ref = ref<Component<NonNullable<unknown>> | Element | null>(null)

  let unsubscribe: () => void = () => { }

  const update = () => {
    unsubscribe()
    unsubscribe = subscribe(receiver, node, _node, _ref)
    reload(receiver, node, _node)
  }

  const unwatch = watch([receiver, node], update)

  return {
    node: _node,
    properties: _properties.ref,
    ref: _ref,
    update,
    release: () => {
      _properties.release()
      _ref.value = null
      unwatch()
      unsubscribe()
    },
  }
}

function subscribe<T extends Received>(
  receiver: ShallowRef<Receiver>,
  src: ShallowRef<T>,
  dst: ShallowRef<T>,
  ref: Ref<Component<NonNullable<unknown>> | Element | null>
) {
  return fuse([
    receiver.value.tree.updatable(src.value, () => reload(receiver, src, dst)),
    receiver.value.tree.invokable(src.value, (method: string, payload: unknown[]) => {
      const el = ref.value
      if (el == null) {
        throw new Error(`${print(src.value)} not mounted to host environment yet`)
      }

      if (!(method in el)) {
        throw new Error(`${print(src.value)} doesn't support method ${method}`)
      }

      const callable = el[method as keyof typeof el] as unknown
      if (!isFunction(callable)) {
        throw new Error(`${print(src.value)} doesn't support method ${method}`)
      }

      return callable.call(el, ...payload)
    }),
  ])
}

function print <T extends Received>(node: T) {
  const { id, kind } = node
  return 'type' in node
    ? `Node [ID=${id}, KIND=${kind}, TYPE=${node.type}]`
    : `Node [ID=${id}, KIND=${kind}]`
}

function reload<T extends Received>(
  receiver: ShallowRef<Receiver>,
  src: ShallowRef<T>,
  dst: ShallowRef<T>
) {
  const n = receiver.value.tree.get(src.value)
  if (n && isUpdated(n, dst.value)) {
    dst.value = { ...n } as T
  }
}

function fuse (handlers: Array<() => void>) {
  return () => handlers.forEach(fn => fn())
}

const propertiesOf = (node: Received) => 'properties' in node ? node.properties : {}

export function useProperties<T extends Received>(node: ShallowRef<T>) {
  const ref: Ref<Unknown> = computed(() => propertiesOf(node.value))
  const unwatch = watch(ref, (newProps, oldProps) => {
    release(oldProps)
    retain(newProps)
  }, { immediate: true })

  return {
    ref,
    release: () => {
      unwatch()
      release(ref.value)
    },
  }
}

const childrenOf = (node: Received) => node && 'children' in node ? node.children : []

function useChildren<T extends Received>(
  parent: ShallowRef<T>,
  hook: (received: ReceivedChild) => Hosted<ReceivedChild>
) {
  const ref: ShallowRef<Hosted[]> = shallowRef(childrenOf(parent.value).map(hook))

  const update = () => ref.value.forEach(({ update }) => update())
  const release = () => ref.value.forEach(({ release }) => release())

  const stopWatch = watch(parent, () => {
    release()
    ref.value = childrenOf(parent.value).map(hook)
    update()
  })

  return {
    ref,
    update,
    release,
    stopWatch,
  }
}
